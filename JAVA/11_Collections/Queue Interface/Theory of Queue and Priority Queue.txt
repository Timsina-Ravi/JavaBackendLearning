 Queue Interface in Java\

The Queue interface in Java follows the FIFO (First-In-First-Out) principle, where elements
are added at the end and removed from the front. It provides methods for efficiently handling
elements in a sequential order, making it suitable for processing tasks in the order they arrive.
The Queue interface extends `Collection` and supports operations like adding, removing, and inspecting elements.


 Methods in Queue

- `offer(E e)`: Adds an element to the queue; returns `true` or `false` if capacity is limited.
- `poll()`: Removes and returns the head of the queue; returns `null` if empty.
- `peek()`: Retrieves the head without removing it; returns `null` if empty.
- `remove()`: Removes and returns the head; throws an exception if the queue is empty.
- `element()`: Retrieves the head without removal; throws an exception if empty.



 Uses of Queue

Queues are widely used in task scheduling, background processing, buffering requests,
breadth-first search (BFS) algorithms, and message queues. They ensure tasks are executed
in the correct order, making them essential in multithreading and real-time data processing.


 PriorityQueue in Java

A PriorityQueue is a specialized queue where elements are ordered by priority instead of FIFO.
By default, it uses natural ordering (smallest element first), but you can customize the priority
using a Comparator. Unlike other queues, a PriorityQueue does not guarantee insertion order,
only that the highest-priority element is at the head. It is implemented as a binary heap for efficient
 retrieval of elements based on priority.


 PriorityQueue-Specific Methods:

- `comparator()`: Returns the Comparator used for ordering elements. Returns `null` if natural ordering is used.
- `clear()`: Removes all elements from the queue.


 Uses of PriorityQueue

PriorityQueue is useful in task scheduling, process management, graph algorithms (Dijkstraâ€™s algorithm),
 and real-time event handling. It ensures that important tasks are processed first, making it valuable
 in thread management, network routing, and database query optimization.
