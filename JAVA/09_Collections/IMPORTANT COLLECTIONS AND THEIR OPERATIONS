
 1. List Interface:
Purpose of List: A List is an ordered collection that allows duplicate elements and access by index.

a) ArrayList:
`ArrayList` is a dynamically resizing array, making it ideal for fast lookups and random access by index.
 It's most efficient when you need to access elements by index frequently but may not be as performant when
 insertions or deletions occur at the beginning or middle of the list.

- Use Case: Ideal for scenarios where you need fast access to elements, such as when dealing with a
 large number of elements where reading and modifying data quickly is more important than frequent insertions
 and deletions (e.g., storing and processing user data, maintaining a collection of elements to search through).

- Key Methods to Learn:
add(E e): Adds an element to the list.
get(int index): Retrieves the element at the specified index.
remove(int index): Removes the element at the specified index.
contains(Object o): Checks if the list contains the specified element.
size(): Returns the number of elements in the list.
clear(): Removes all elements from the list.
indexOf(Object o): Finds the index of the specified element.


b) LinkedList:
`LinkedList` is a doubly linked list, making it ideal for efficient insertions and deletions, particularly at the
start or middle of the list. However, retrieving an element by index takes longer because you must traverse
 the list to find it.

- Use Case: Perfect for applications where you need frequent insertion and removal of elements, especially in the
middle of the list or from both ends (e.g., implementing a queue or deque, managing a playlist where elements
 can be added/removed at the start or end).

- Key Methods to Learn:
  add(E e): Adds an element to the list.
  addFirst(E e): Adds an element to the beginning of the list.
  addLast(E e): Adds an element to the end of the list.
  remove(Object o): Removes the first occurrence of the specified element.
  removeFirst(): Removes the first element.
  removeLast(): Removes the last element.
  get(int index): Retrieves the element at the specified index.
----------------------------------------------------------------------
===================================================

 2. Set Interface:
 Purpose of Set: A Set is a collection that does not allow duplicate elements and does
  not maintain order (except for LinkedHashSet and TreeSet).

a) HashSet:
`HashSet` uses a hash table to store elements, ensuring that each element is unique and has constant-time
complexity for basic operations like adding, removing, and checking for membership.

- Use Case: Suitable for scenarios where you need to ensure uniqueness and perform operations like checking for
 membership quickly (e.g., tracking unique users in a system, eliminating duplicates from a list).

- Key Methods to Learn:
  - `add(E e)`: Adds an element to the set (ensures uniqueness).
  - `remove(Object o)`: Removes an element from the set.
  - `contains(Object o)`: Checks if the set contains the specified element.
  - `size()`: Returns the number of elements in the set.
  - `clear()`: Removes all elements from the set.
  - `iterator()`: Iterates over the elements of the set.


b) LinkedHashSet:
`LinkedHashSet` is similar to `HashSet`, but it maintains insertion order while still ensuring that
the elements are unique.

- Use Case: Useful when you need to store unique elements but also need to maintain the order in which they
were added (e.g., maintaining a collection of unique items in the order they were inserted).

- Key Methods to Learn:
  - `add(E e)`: Adds an element to the set.
  - `remove(Object o)`: Removes an element from the set.
  - `contains(Object o)`: Checks if the set contains the specified element.
  - `size()`: Returns the number of elements in the set.
  - `clear()`: Removes all elements from the set.
  - `iterator()`: Iterates over the elements of the set.


c) TreeSet:
`TreeSet` implements the SortedSet interface and stores elements in a sorted order, based on their
 natural ordering or by a comparator.

- Use Case: Ideal for applications where you need unique elements that must be stored in a sorted order
(e.g., maintaining a sorted list of users, storing ordered data such as timestamps).

- Key Methods to Learn:
add(E e): Adds an element to the set.
remove(Object o): Removes an element from the set.
contains(Object o): Checks if the set contains the specified element.
first(): Retrieves the smallest element in the set.
last(): Retrieves the largest element in the set.
subSet(): Returns a subset of the set.

---------------------------------------------------------------
=====================================================

 3. Map Interface:
Purpose of Map: A Map is a collection that stores key-value pairs, where each key is unique,
 and the map can retrieve values based on the key.

a) HashMap:
`HashMap` stores data in key-value pairs and uses a hash table to provide fast key-value lookups
 with constant-time complexity.

- Use Case: Ideal for applications where you need to store and quickly access key-value pairs
(e.g., caching data, user preferences, or mapping user IDs to user data).

- Key Methods to Learn:
 put(K key, V value): Adds a key-value pair to the map.
 get(Object key): Retrieves the value for a given key.
 remove(Object key): Removes the key-value pair for the specified key.
 containsKey(Object key): Checks if the map contains the specified key.
 keySet(): Returns the set of keys.
 values(): Returns the collection of values

b) LinkedHashMap:
`LinkedHashMap` is similar to `HashMap` but it maintains the insertion order of key-value pairs.

- Use Case: Useful when you need to store key-value pairs while preserving the order in which they were inserted
(e.g., when caching data but maintaining the order of insertion).

- Key Methods to Learn:
 put(K key, V value): Adds a key-value pair to the map.
 get(Object key): Retrieves the value for a given key.
 remove(Object key): Removes the key-value pair for the specified key.
 containsKey(Object key): Checks if the map contains the specified key.
 keySet(): Returns the set of keys.
 values(): Returns the collection of values


c) TreeMap:
`TreeMap` stores key-value pairs in a sorted order and implements the `NavigableMap` interface, which
 provides methods for efficiently navigating through keys.

- Use Case: Ideal when you need sorted data in the form of key-value pairs, such as implementing a
sorted map of ranges, or maintaining an ordered index (e.g., storing a sorted list of contacts by name).

- Key Methods to Learn:
put(K key, V value): Adds a key-value pair to the map.
get(Object key): Retrieves the value for a given key.
remove(Object key): Removes the key-value pair for the specified key.
containsKey(Object key): Checks if the map contains the specified key.
firstKey(): Retrieves the smallest key in the map.
lastKey(): Retrieves the largest key in the map.
--------------------------------------------------------------
================================================================

 4. Queue Interface:

 Purpose of Queue: A Queue is a collection that follows the FIFO (First In, First Out) principle, where elements are
 processed in the order they were added.

a) PriorityQueue:
`PriorityQueue` is a heap-based queue that orders elements based on their priority, which is determined either by their
 natural ordering or by a comparator.

- Use Case: Perfect for scenarios where elements need to be processed in order of priority, such as scheduling tasks
 based on priority or managing a priority-based job queue.

- Key Methods to Learn:
  - `offer(E e)`: Adds an element to the queue (with priority).
  - `poll()`: Retrieves and removes the highest-priority element.
  - `peek()`: Retrieves the highest-priority element without removing it.


b) ArrayDeque:
`ArrayDeque` is a resizable array implementation of the `Deque` interface that supports both stack and
queue operations with good performance.

- Use Case: Great for applications requiring efficient queue or stack operations, such as implementing
 a sliding window, undo/redo stacks, or breadth-first search in graphs.

- Key Methods to Learn:
  - `offer(E e)`: Adds an element to the queue (end).
  - `poll()`: Retrieves and removes the front element of the queue.
  - `peek()`: Retrieves the front element without removing it.
  - `addFirst(E e)`: Adds an element to the front (works as stack).
  - `addLast(E e)`: Adds an element to the end (works as queue).
  - `removeFirst()`: Removes the first element.
  - `removeLast()`: Removes the last element.


c) LinkedList:
`LinkedList` can be used as both a queue and deque, providing efficient operations at both ends of the collection.

- Use Case: Ideal for applications requiring efficient insertions and deletions from both ends of the collection
 (e.g., implementing a queue for processing tasks or using it as a stack).

- Key Methods to Learn:
  - `offer(E e)`: Adds an element to the queue.
  - `poll()`: Retrieves and removes the front element of the queue.
  - `peek()`: Retrieves the front element without removing it.
  - `addFirst(E e)`: Adds an element to the front.
  - `addLast(E e)`: Adds an element to the end.
  - `removeFirst() : Removes the first element.
  - `removeLast()`: Removes the last element.
